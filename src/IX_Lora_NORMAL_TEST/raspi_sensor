
#define MAXPACKETLENGTH 256
#define MAXPACKET 64
#define MAXBUFFER MAXPACKETLENGTH * MAXPACKET


#include <Arduino.h>

#include <RadioLib.h>
#include <SPI.h>
#include <EEPROM.h>

#include <vector>
#include <queue>
#include <utility>
#include <math.h>

#include "pinoutSX1262.h"
#include "config.h"
#include "IX_state.h"

#include <Wire.h>
#include <Adafruit_MS8607.h>
#include <SparkFun_u-blox_GNSS_v3.h>

// ENABLE MS8607 BAROMETER AND UBLOX GNSS V3
#define ENABLE_SENSOR 1

// Lora
SPIClass spi1(LORA_MOSI,LORA_MISO,LORA_SCLK);  

SPISettings lora_spi_settings(8000000, MSBFIRST, SPI_MODE0);

SX1262 radio = new Module(LORA_NSS, LORA_DIO1, LORA_NRST, LORA_BUSY, spi1, lora_spi_settings);

// BAROMETER
Adafruit_MS8607 ms8607;

// GNSS
SFE_UBLOX_GNSS max10s;

// RADIO
bool inTx;
bool enableRadio = false;

// flag
volatile bool txFlag = false;

// PACKET TEMP VARIABLE
int n,i;

// PACKET CONFIG
uint8_t maxPacket = 245;

// COUNTING
uint8_t frameCount;
uint8_t maxFrame = 9;

// PACKET BUFFER
byte buffer[MAXBUFFER];
int buffer_length;

// UART               RX   TX
HardwareSerial raspi(PA3, PA2);

// HEADER ENDER
String header,ender;

// CHUNK TEMPERARY
byte chunk[MAXPACKET][MAXPACKETLENGTH];
int current_chunk = 0;
int lenChunk = 0;

// PACKET
byte* top_packet;
std::queue<std::pair<byte*,int>>packet;
int packet_left = 255;

// STATE
uint8_t stm32_state;
int state;

// INTERVAL
struct interval
{
  uint32_t get_packet = 1 * 1000;
  uint32_t raspi_check = 10 * 1000;
  uint32_t log = 10 * 1000;
  uint32_t baro = 0.1 * 1000;
  uint32_t gps = 0.1 * 1000; 
  uint32_t cal_apogee = 0.1 * 1000;
}interval;

struct last
{
  uint32_t get_packet = millis();
  uint32_t raspi_check = millis(); 
  uint32_t baro = millis();
  uint32_t gps = millis();
  uint32_t log = millis();
  uint32_t cal_apogee = millis();
}last;

// GPS
std::tuple<float,float,float> gps;
float lat,lon,alt;
byte SIV;

// FILTER ALTITUDE
float altFiltered = 0;
float alpha = 0.08;
float lastAltBaro = 0;
float climbRate = 0;
float highestBaro = 0;
float highestGPS = 0;

// APOGEE
uint32_t Baro_ApogeeCount = 0;
uint32_t GPS_ApogeeCount = 0;
bool BaroApogee = false;
bool GPSApogee = false;
float GPS_error_rate = 0;
float baro_error_rate = 0;
int max_apogee_time = 3; // sec

// VALUE
float altBaro;
float altGPS;
sensors_event_t temp, pressure, humidity;    


// VALUE
/*
  NORMAL : SEND GARBARGE DATA
  APOGEE : TRY TO GET IMAGE FROM RASPI
  SUCCESS : FINISH GE IMAGE FROM RASPI
*/

// SETUP
void setup() {
  Serial.begin(115200);
  // while(!Serial);
  delay(4000);

  Serial.println("RX BUFFER SIZE: " + String(SERIAL_RX_BUFFER_SIZE));

  Serial.println(F("[SX1262] Initializing ... "));

  // SPI
  Wire.begin();

  Wire.setTimeout(10);

  // // MS8607 BAROMETER
  if (ms8607.begin() == false) {
    Serial.println("MS8607 failed to start");
    delay(1000);
  }
  else{
    Serial.println("MS8607 success to start");
  }
  // 0x42
  if (max10s.begin() == false) {
    Serial.println("Max-m10s failed to start");
    delay(1000);
  }
  else{
    Serial.println("Max-m10s success to start");
  }

  // STATE
  stm32_state = NORMAL;

  // CLEAN BUFFER
  while(raspi.available()) { raspi.read(); } 

  Serial.println("Start loop");
}

void loop(){
  if (millis() - last.log > interval.log){
    if(packet.empty()){
      digitalWrite(LED_BUILTIN,HIGH);
    }
    else{
      digitalWrite(LED_BUILTIN,LOW);
    }
    
    last.log = millis();
    
    Serial.println();
    Serial.println("===============STATE===============");
    Serial.println("STATE RASPI: " + String(stm32_state));
    Serial.println("=============PACKETLEFT============");
    Serial.println("PACKET LEFT FROM QUEUE: " + String(packet.size()));
    Serial.println("PACKET LEFT FROM COUNTING: " + String(packet_left));
    Serial.println("NEED PACKET? : " + String(stm32_state == NORMAL && packet.empty()));
    Serial.println("===============RADIO===============");
    Serial.println("IN TX: " + String(inTx));
    // Serial.println("==============BARO==============");
    // Serial.println("TEMPERATUE: " + String(temp.temperature));
    // Serial.println("PRESSURE: " + String(pressure.pressure));
    // Serial.println("HUMIDITY: " + String(humidity.relative_humidity));
    // Serial.println("ALT: " + String(altBaro));
    Serial.println("===============GPS===============");
    Serial.println("LAT: " + String(lat));
    Serial.println("LON: " + String(lon));
    Serial.println("ALT: " + String(alt));
    Serial.println("SIV: " + String(SIV));

    Serial.println();
  }

  if(ENABLE_SENSOR){
    // BAROMETER
    if(millis() - last.baro > interval.baro){
      last.baro = millis();

      ms8607.getEvent(&pressure, &temp, &humidity);
      altBaro = 44300 * (1 - pow((pressure.pressure / 1013.25), 1.0 / 5.256));

      altFiltered = alpha * altBaro + (1 - alpha) * altFiltered;

      climbRate = altFiltered - lastAltBaro;
      lastAltBaro = altFiltered;
    }

    // GPS
    if(millis() - last.gps > interval.gps){
      last.gps = millis();

      if (max10s.getFixType()==3){
        altGPS = max10s.getAltitudeMSL()/1000.0;

        max10s.
        lat = max10s.getLatitude()/1000.0;
        lon = max10s.getLongitude()/1000.0;
        alt = max10s.getAltitude()/1000.0;
      }
    }

    // APOGEE
    if(millis() - last.cal_apogee < interval.cal_apogee){
      last.cal_apogee = millis();
      // BARO
      if(!BaroApogee){
        if (altFiltered > highestBaro) {
          highestBaro = altFiltered;
        }
        // FALLING
        if ((highestBaro > altBaro + baro_error_rate && BaroApogee) ||(highestBaro <  altBaro - baro_error_rate && !BaroApogee)){
          Baro_ApogeeCount += 1;
          if (Baro_ApogeeCount > max_apogee_time * ((1 * 1000) / interval.cal_apogee)){
            BaroApogee = !BaroApogee;
          }
        }
        else if((highestBaro > altBaro + baro_error_rate && !BaroApogee) ||(highestBaro <  altBaro - baro_error_rate && BaroApogee)){
          Baro_ApogeeCount = 0;
        }
      }
      // GPS
      if (!GPSApogee){
        if (altGPS> highestGPS) {
          highestGPS = altGPS;
        }
        // FALLING
        if ((highestGPS > altGPS + GPS_error_rate && GPSApogee) ||(highestGPS <  altGPS - GPS_error_rate && !GPSApogee)){
          GPS_ApogeeCount += 1;
          if (GPS_ApogeeCount > max_apogee_time * ((1 * 1000) / interval.cal_apogee)){
            GPSApogee = !GPSApogee;
          }
        }
        else if((highestGPS > altGPS + GPS_error_rate && !GPSApogee) ||(highestGPS <  altGPS - GPS_error_rate && GPSApogee)){
          GPS_ApogeeCount = 0;
        }
      }
    }

    if (BaroApogee){
      handle_apogee();
    }
  }
}